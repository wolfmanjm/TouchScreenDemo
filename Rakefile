require 'rake'
require 'pathname'
require 'fileutils'


PROG = 'touch_screen'

$using_cpp= false

def pop_path(path)
  Pathname(path).each_filename.to_a[1..-1]
end

def obj2src(fn, e)
  File.join(PROG, pop_path(File.dirname(fn)), File.basename(fn).ext(e))
end

def is_windows?
  (/cygwin|mswin|mingw|bccwin|wince|emx/ =~ RUBY_PLATFORM) != nil
end

# Makefile .d file loader to be used with the import file loader.
# this emulates the -include $(DEPFILES) in a Makefile for the generated .d files
class DfileLoader
  include Rake::DSL

  SPACE_MARK = "\0"

  # Load the makefile dependencies in +fn+.
  def load(fn)
    return if ! File.exists?(fn)
    lines = File.read fn
    lines.gsub!(/\\ /, SPACE_MARK)
    lines.gsub!(/#[^\n]*\n/m, "")
    lines.gsub!(/\\\n/, ' ')
    lines.each_line do |line|
      process_line(line)
    end
  end

  private

  # Process one logical line of makefile data.
  def process_line(line)
    file_tasks, args = line.split(':', 2)
    return if args.nil?
    dependents = args.split.map { |d| respace(d) }
    file_tasks.scan(/\S+/) do |file_task|
      file_task = respace(file_task)
      file file_task => dependents
    end
  end

  def respace(str)
    str.tr SPACE_MARK, ' '
  end
end

# Install the handler
Rake.application.add_loader('d', DfileLoader.new)

TOOLSBIN = 'arm-none-eabi-'
CC = "#{TOOLSBIN}gcc"
CCPP = "#{TOOLSBIN}g++"
LD = "#{TOOLSBIN}gcc"
LDCPP = "#{TOOLSBIN}g++"
OBJCOPY = "#{TOOLSBIN}objcopy"
SIZE = "#{TOOLSBIN}size"

# include a defaults file if present
load 'rakefile.defaults' if File.exists?('rakefile.defaults')

# Set build type
#BUILDTYPE= ENV['BUILDTYPE'] || 'Checked' unless defined? BUILDTYPE
#puts "#{BUILDTYPE} build"

excludes= [] # ['t.cpp']
SRC = FileList[PROG + '/**/*.{c,cpp,s}']
SRC.exclude(/#{excludes.join('|')}/) unless excludes.empty?
$using_cpp= SRC.find { |i| File.extname(i) == ".cpp" }.nil? ? false : true

OBJDIR = "#{PROG}_BUILD"
OBJ = SRC.collect { |fn| File.join(OBJDIR, pop_path(File.dirname(fn)), File.basename(fn).ext('o')) }
    # + %W(#{OBJDIR}/configdefault.o #{OBJDIR}/mbed_custom.o)

# list of header dependency files generated by compiler
DEPFILES = OBJ.collect { |fn| File.join(File.dirname(fn), File.basename(fn).ext('d')) }

# create destination directories
SRC.each do |s|
  d= File.join(OBJDIR, pop_path(File.dirname(s)))
  FileUtils.mkdir_p(d) unless Dir.exists?(d)
end

INCLUDE_DIRS = ['Inc', 'Drivers/STM32L1xx_HAL_Driver/Inc', 'Drivers/CMSIS/Include', 'Drivers/CMSIS/Device/ST/STM32L1xx/Include'].collect { |d| "#{PROG}/#{d}" }

# [Dir.glob([PROG + '/**/Inc/**', './mri/**/'])].flatten

INCLUDE = (INCLUDE_DIRS).collect { |d| "-I#{d}" }.join(" ")

#SYS_LIBS = '-lstdc++_s -lsupc++_s -lm -lgcc -lc_s -lgcc -lc_s -lnosys'
SYS_LIBS = ''
LIBS = [SYS_LIBS].join(' ')

defines = %w(-DUSE_HAL_DRIVER -DSTM32L100xC)
DEFINES= defines.join(' ')

# Compiler flags used to enable creation of header dependencies.
DEPFLAGS = '' # '-MMD '
CFLAGS = DEPFLAGS + "-mthumb -mcpu=cortex-m3 -Os -ffunction-sections -fdata-sections -g -Wall -fno-exceptions -fno-delete-null-pointer-checks"
CPPFLAGS = CFLAGS + ' -fno-rtti -std=gnu++11'

# Linker script to be used.  Indicates what code should be placed where in memory.
LSCRIPT = "#{PROG}/STM32L100RC_FLASH.ld"
LDFLAGS = "-g -mthumb -mcpu=cortex-m3 -Wl,--start-group -lc -lm -Wl,--end-group -static -Wl,-cref,-u,Reset_Handler -Wl,-Map=#{OBJDIR}/#{PROG}.map -Wl,--gc-sections -Wl,--defsym=malloc_getpagesize_P=0x1000" +
    " -T#{LSCRIPT} -u _scanf_float -u _printf_float -fno-rtti -fno-exceptions "

# tasks
desc "Upload via stlink"
task :upload do
  sh "./flashit #{OBJDIR}/#{PROG}.bin"
end

# generate the header dependencies if they exist
import(*DEPFILES)

task :clean do
  FileUtils.rm_rf(OBJDIR)
end

task :default => [:build]

task :build => ["#{PROG}.bin", :size]

task :size do
  sh "#{SIZE} #{OBJDIR}/#{PROG}.elf"
end

file "#{PROG}.bin" => ["#{PROG}.elf"] do
  sh "#{OBJCOPY} -O binary #{OBJDIR}/#{PROG}.elf #{OBJDIR}/#{PROG}.bin"
end

file "#{PROG}.elf" => OBJ do |t|
  puts "Linking #{t.source}"
  sh "#{$using_cpp ? LDCPP : LD} #{LDFLAGS} #{OBJ} #{LIBS}  -o #{OBJDIR}/#{t.name}"
end

#arm-none-eabi-objcopy -R .stack -O ihex ../LPC1768/main.elf ../LPC1768/main.hex
#arm-none-eabi-objdump -d -f -M reg-names-std --demangle ../LPC1768/main.elf >../LPC1768/main.disasm

rule '.o' => lambda{ |objfile| obj2src(objfile, 'cpp') } do |t|
  puts "Compiling #{t.source}"
  sh "#{CCPP} #{CPPFLAGS} #{INCLUDE} #{DEFINES} -c -o #{t.name} #{t.source}"
end

rule '.o' => lambda{ |objfile| obj2src(objfile, 'c') } do |t|
  puts "Compiling #{t.source}"
  sh "#{CC} #{CFLAGS} #{INCLUDE} #{DEFINES} -std=c99 -c -o #{t.name} #{t.source}"
end

rule '.o' => lambda{ |objfile| obj2src(objfile, 's') } do |t|
  puts "Assembling #{t.source}"
  sh "#{CC} -c -mthumb -mcpu=cortex-m3  -g -Wa,--no-warn -x assembler-with-cpp #{INCLUDE} -o #{t.name} #{t.source}"
end
